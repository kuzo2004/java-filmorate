package ru.yandex.practicum.filmorate.annotation;

import jakarta.validation.Constraint;
import jakarta.validation.Payload;
import ru.yandex.practicum.filmorate.validator.MinReleaseDateValidator;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = MinReleaseDateValidator.class)
public @interface MinReleaseDate {
    String message() default "Дата релиза не может быть раньше 28 декабря 1895 года";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};
}
package ru.yandex.practicum.filmorate.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;
import ru.yandex.practicum.filmorate.model.Film;
import jakarta.validation.Valid;
import ru.yandex.practicum.filmorate.service.FilmService;

import java.util.List;
import java.util.Collection;

@Slf4j
@RestController
@RequestMapping("/films")
public class FilmController {
    private final FilmService filmService;

    public FilmController(FilmService filmService) {
        this.filmService = filmService;
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Film addFilm(@Valid @RequestBody Film film) {
        return filmService.addFilm(film);
    }

    @PutMapping
    @ResponseStatus(HttpStatus.OK)
    public Film updateFilm(@Valid @RequestBody Film updatedFilm) {
        return filmService.updateFilm(updatedFilm);
    }

    @GetMapping("/{id}")
    public Film getFilm(@PathVariable int id) {
        return filmService.getFilm(id);
    }

    @GetMapping
    public Collection<Film> getAllFilms() {
        return filmService.getAllFilms();
    }

    // Пользователь ставит лайк фильму
    @PutMapping("/{id}/like/{userId}")
    public void addLike(@PathVariable int id,
                        @PathVariable int userId) {
        filmService.addLike(id, userId);
    }

    // Пользователь удаляет лайк
    @DeleteMapping("/{id}/like/{userId}")
    public void removeLike(@PathVariable int id,
                           @PathVariable int userId) {
        filmService.removeLike(id, userId);
    }

    // Возвращается список из первых count фильмов по количеству лайков
    @GetMapping("/popular")
    public List<Film> getPopularFilms(
            @RequestParam(defaultValue = "10") int count) {
        return filmService.getPopularFilms(count);
    }
}
package ru.yandex.practicum.filmorate.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.*;
import ru.yandex.practicum.filmorate.model.User;
import jakarta.validation.Valid;
import ru.yandex.practicum.filmorate.service.UserService;

import java.util.List;
import java.util.Collection;


@Slf4j
@RestController
@RequestMapping("/users")
public class UserController {
    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public User createUser(@Valid @RequestBody User user) {
        return userService.addUser(user);
    }

    @PutMapping
    @ResponseStatus(HttpStatus.OK)
    public User updateUser(@Valid @RequestBody User user) {
        return userService.updateUser(user);

    }

    @GetMapping("/{id}")
    public User getUser(@PathVariable int id) {
        return userService.getUser(id);
    }

    @GetMapping
    public Collection<User> getAllUsers() {
        return userService.getAllUsers();
    }

    // Добавление в друзья
    @PutMapping("/{id}/friends/{friendId}")
    public void addFriend(@PathVariable int id,
                          @PathVariable int friendId) {
        userService.addFriend(id, friendId);
    }

    // Удаление из друзей
    @DeleteMapping("/{id}/friends/{friendId}")
    public void removeFriend(@PathVariable int id,
                             @PathVariable int friendId) {
        userService.removeFriend(id, friendId);
    }

    // Список пользователей, являющихся его друзьями
    @GetMapping("/{id}/friends")
    public List<User> getFriends(@PathVariable int id) {
        return userService.getFriends(id);
    }

    // Список друзей, общих с другим пользователем
    @GetMapping("/{id}/friends/common/{otherId}")
    public List<User> getCommonFriends(
            @PathVariable int id,
            @PathVariable int otherId) {
        return userService.getCommonFriends(id, otherId);
    }
}

/*
package ru.yandex.practicum.filmorate;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.zalando.logbook.*;
import org.zalando.logbook.json.JsonHttpLogFormatter;

import java.io.IOException;

public class CustomLogbookFormatter implements HttpLogFormatter {
    private final JsonHttpLogFormatter delegate = new JsonHttpLogFormatter();
    private final ObjectMapper mapper = new ObjectMapper();

    @Override
    public String format(Precorrelation precorrelation, HttpRequest request) throws IOException {
        ObjectNode json = (ObjectNode) mapper.readTree(delegate.format(precorrelation, request));
        return filterFields(json).toString();
    }

    @Override
    public String format(Correlation correlation, HttpResponse response) throws IOException {
        ObjectNode json = (ObjectNode) mapper.readTree(delegate.format(correlation, response));
        return filterFields(json).toString();
    }

    private ObjectNode filterFields(ObjectNode original) {
        ObjectNode filtered = mapper.createObjectNode();

        // Копируем только нужные поля
        if (original.has("method")) filtered.set("method", original.get("method"));
        if (original.has("path")) filtered.set("path", original.get("path"));
        if (original.has("status")) filtered.set("status", original.get("status"));
        if (original.has("body")) filtered.set("body", original.get("body"));

        return filtered;

}
*/
package ru.yandex.practicum.filmorate.exception;

import jakarta.validation.ConstraintViolationException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.stream.Collectors;

@Slf4j
@RestControllerAdvice
public class ErrorHandler {

    @ExceptionHandler(ValidationExceptionDuplicate.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST) // 400
    public ErrorResponse handleValidationExceptionDuplicate(ValidationExceptionDuplicate e) {
        log.warn("Ошибка валидации: {}", e.getMessage());
        return new ErrorResponse(e.getMessage());
    }

    @ExceptionHandler(NotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND) // 404
    public ErrorResponse handleNotFoundException(NotFoundException e) {
        log.warn("Объект не найден: {}", e.getMessage());
        return new ErrorResponse(e.getMessage());
    }

    // Обработка ошибок валидации (@Valid)
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST) // 400
    public ErrorResponse handleMethodArgumentNotValid(MethodArgumentNotValidException e) {
        String errorMessage = e.getBindingResult().getAllErrors().stream()
                               .map(error -> ((FieldError) error).getField() + ": "
                                       + error.getDefaultMessage())
                               .collect(Collectors.joining("; "));
        log.warn("Ошибки валидации полей: {}", errorMessage);
        return new ErrorResponse("Ошибки валидации: " + errorMessage);
    }

    // Обработка ошибок от кастомных валидаторов
    @ExceptionHandler(ConstraintViolationException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST) // 400
    public ErrorResponse handleConstraintViolation(ConstraintViolationException e) {
        String errorMessage = e.getConstraintViolations().stream()
                               .map(violation -> violation.getPropertyPath() + ": "
                                       + violation.getMessage())
                               .collect(Collectors.joining("; "));
        log.warn("Ошибки валидации: {}", errorMessage);
        return new ErrorResponse("Ошибки валидации: " + errorMessage);
    }

    @ExceptionHandler
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) // 500
    public ErrorResponse handleNotFoundException(Throwable e) {
        log.warn("Внутренняя ошибка сервера: {}", e.getMessage());
        return new ErrorResponse(e.getMessage());
    }
}



package ru.yandex.practicum.filmorate.exception;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class ErrorResponse {
    private final String error;
}
package ru.yandex.practicum.filmorate.exception;

public class NotFoundException extends RuntimeException {
    public NotFoundException(String message) {
        super(message);
    }
}
package ru.yandex.practicum.filmorate.exception;

public class ValidationExceptionDuplicate extends RuntimeException {
    public ValidationExceptionDuplicate(String message) {
        super(message);
    }
}
package ru.yandex.practicum.filmorate;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class FilmorateApplication {
    public static void main(String[] args) {
        SpringApplication.run(FilmorateApplication.class, args);
    }
}
/*
package ru.yandex.practicum.filmorate;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.zalando.logbook.*;
import org.zalando.logbook.core.DefaultHttpLogWriter;
import org.zalando.logbook.core.DefaultSink;

@Configuration
public class LogbookConfig {
    @Bean
    public Logbook logbook() {
        return Logbook.builder()
                      .sink(new DefaultSink(
                              new CustomLogbookFormatter(),
                              new DefaultHttpLogWriter()
                      ))
                      .build();
    }
}*/
package ru.yandex.practicum.filmorate.model;

import jakarta.validation.constraints.*;
import lombok.Data;
import ru.yandex.practicum.filmorate.annotation.MinReleaseDate;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Data
public class Film {
    private int id;

    @NotBlank(message = "Название фильма не может быть пустым")
    private String name;

    @Size(max = 200, message = "Описание не должно превышать 200 символов")
    private String description;

    @NotNull(message = "Дата релиза обязательна")
    @PastOrPresent(message = "Дата релиза должна быть в прошлом или настоящем")
    @MinReleaseDate
    private LocalDate releaseDate;

    @NotNull(message = "Продолжительность фильма не должна быть пустой")
    @Positive(message = "Продолжительность фильма должна быть положительной")
    private Integer duration;

    private Set<Integer> likes = new HashSet<>();

    public Film() {
        this.likes = new HashSet<>();
    }
}
package ru.yandex.practicum.filmorate.model;

import jakarta.validation.constraints.*;
import lombok.Data;
import ru.yandex.practicum.filmorate.annotation.MinReleaseDate;

import java.time.LocalDate;

@Data
public class FilmUpdateDTO {
    @Positive(message = "Id фильма должен быть положительным")
    private int id;

    private String name;

    @Size(max = 200, message = "Описание не должно превышать 200 символов")
    private String description;


    @PastOrPresent(message = "Дата релиза должна быть в прошлом или настоящем")
    @MinReleaseDate
    private LocalDate releaseDate;

    @Positive(message = "Продолжительность фильма должна быть положительной")
    private Integer duration;
}
package ru.yandex.practicum.filmorate.model;

import jakarta.validation.constraints.*;
import lombok.Data;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Data
public class User {
    private int id;

    @NotBlank(message = "Email не может быть пустым")
    @Email(message = "Email должен быть корректным")
    private String email;

    @NotBlank(message = "Логин не может быть пустым")
    @Pattern(regexp = "\\S+", message = "Логин не должен содержать пробелы")
    private String login;

    private String name;

    @PastOrPresent(message = "Дата рождения не может быть в будущем")
    private LocalDate birthday;

    private Set<Integer> friends = new HashSet<>();

    public User() {
        this.friends = new HashSet<>();
    }
}package ru.yandex.practicum.filmorate.model;

import jakarta.validation.constraints.*;
import lombok.Data;

import java.time.LocalDate;

@Data
public class UserUpdateDTO {
    @Positive(message = "Id пользователя должен быть положительным")
    private int id;

    @Email(message = "Email должен быть корректным")
    private String email;

    @Pattern(regexp = "\\S+", message = "Логин не должен содержать пробелы")
    private String login;

    private String name;

    @PastOrPresent(message = "Дата рождения не может быть в будущем")
    private LocalDate birthday;
}
package ru.yandex.practicum.filmorate.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import ru.yandex.practicum.filmorate.exception.NotFoundException;
import ru.yandex.practicum.filmorate.exception.ValidationExceptionDuplicate;
import ru.yandex.practicum.filmorate.model.Film;
import ru.yandex.practicum.filmorate.storage.film.FilmStorage;

import java.util.Comparator;
import java.util.Collection;
import java.util.List;

@Slf4j
@Service
public class FilmService {

    private final FilmStorage filmStorage;
    private final UserService userService;

    public FilmService(FilmStorage filmStorage, UserService userService) {
        this.filmStorage = filmStorage;
        this.userService = userService;
    }

    public Film addFilm(Film film) {
        Film addedFilm = filmStorage.addFilm(film);
        log.debug("Фильм добавлен: {}", addedFilm);
        return addedFilm;
    }

    public Film updateFilm(Film film) {
        // Проверяем существование фильма
        Film existingFilm = getFilm(film.getId());
        // Сохраняем существующие лайки при обновлении
        film.setLikes(existingFilm.getLikes());

        Film updatedFilm = filmStorage.updateFilm(film);
        log.debug("Фильм полностью обновлен: {}", updatedFilm);
        return updatedFilm;
    }

    public Film getFilm(int id) {
        Film film = filmStorage.getFilm(id);
        if (film == null) {
            throw new NotFoundException("Фильм с ID " + id + " не найден");
        }
        return film;
    }

    public Collection<Film> getAllFilms() {
        return filmStorage.getAllFilms();
    }

    public void addLike(int filmId, int userId) {
        Film film = getFilm(filmId);

        // Проверить существование пользователя
        userService.getUser(userId);

        // Проверить существование лайка
        if (film.getLikes().contains(userId)) {
            log.debug(String.format("Пользователь %d уже ставил лайк фильму %d", userId, filmId));
            throw new ValidationExceptionDuplicate(
                    String.format("Пользователь %d уже ставил лайк фильму %d", userId, filmId)
            );
        }
        film.getLikes().add(userId);

        filmStorage.updateFilm(film);
        log.debug("Пользователь {} поставил лайк фильму {}", userId, filmId);
    }

    public void removeLike(int filmId, int userId) {
        Film film = getFilm(filmId);

        // Проверить существование пользователя
        userService.getUser(userId);

        if (!film.getLikes().remove(userId)) {
            log.debug("Лайк пользователя {} для фильма {} не найден", userId, filmId);
            return;
        }
        filmStorage.updateFilm(film);
        log.debug("Пользователь {} удалил лайк у фильма {}", userId, filmId);
    }

    public List<Film> getPopularFilms(int count) {
        return filmStorage.getAllFilms().stream()
                          .sorted(Comparator.comparingInt(f -> -f.getLikes().size()))
                          .limit(count)
                          .toList();
    }
}package ru.yandex.practicum.filmorate.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import ru.yandex.practicum.filmorate.exception.NotFoundException;
import ru.yandex.practicum.filmorate.exception.ValidationExceptionDuplicate;
import ru.yandex.practicum.filmorate.model.User;
import ru.yandex.practicum.filmorate.storage.user.UserStorage;

import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.util.HashSet;

@Slf4j
@Service
public class UserService {
    private final UserStorage userStorage;

    public UserService(UserStorage userStorage) {
        this.userStorage = userStorage;
    }

    public User addUser(User user) {
        // Проверка уникальности email и login
        checkEmailUniqueness(user.getEmail(), null);
        checkLoginUniqueness(user.getLogin(), null);

        // Установка name = login, если name пустое
        if (user.getName() == null || user.getName().isBlank()) {
            user.setName(user.getLogin());
        }
        User addedUser = userStorage.addUser(user);
        log.debug("Создан пользователь: {}", addedUser);
        return addedUser;
    }

    public User updateUser(User user) {
        // Проверяем существование пользователя
        User existingUser = getUser(user.getId()); // Выбросит NotFoundException, если не найден

        // Проверяем уникальность email и login (кроме текущего пользователя)
        checkEmailUniqueness(user.getEmail(), user.getId());
        checkLoginUniqueness(user.getLogin(), user.getId());

        // Подставляем login, если name пустое
        if (user.getName() == null || user.getName().isBlank()) {
            user.setName(user.getLogin());
        }
        // Сохраняем существующих друзей при обновлении
        user.setFriends(existingUser.getFriends());

        User updatedUser = userStorage.updateUser(user);
        log.debug("Пользователь полностью обновлен: {}", updatedUser);
        return updatedUser;
    }

    public User getUser(int id) {
        User user = userStorage.getUser(id);
        if (user == null) {
            throw new NotFoundException("Пользователь с ID " + id + " не найден");
        }
        return user;
    }

    public Collection<User> getAllUsers() {
        return userStorage.getAllUsers();
    }

    public void addFriend(int userId, int friendId) {
        if (userId == friendId) {
            log.debug("Пользователь {} пытается добавить самого себя в друзья", userId);
            throw new ValidationExceptionDuplicate("Нельзя добавить самого себя в друзья");
        }

        User user = getUser(userId);
        User friend = getUser(friendId);

        if (user.getFriends().contains(friendId)) {
            log.debug(String.format("Пользователь %d уже есть в друзьях у пользователя %d", friendId, userId));
            throw new ValidationExceptionDuplicate(
                    String.format("Пользователь %d уже есть в друзьях у пользователя %d", friendId, userId));
        }

        if (friend.getFriends().contains(userId)) {
            log.debug(String.format("Пользователь %d уже есть в друзьях у пользователя %d", userId, friendId));
            throw new ValidationExceptionDuplicate(
                    String.format("Пользователь %d уже есть в друзьях у пользователя %d", userId, friendId));
        }

        user.getFriends().add(friendId);
        friend.getFriends().add(userId);

        userStorage.updateUser(user);
        userStorage.updateUser(friend);
        log.debug("Пользователи {} и  {} добавлены в друзья к друг другу", user, friend);
    }

    public void removeFriend(int userId, int friendId) {
        if (userId == friendId) {
            log.debug("Пользователь {} пытается удалить самого себя из друзей", userId);
            throw new ValidationExceptionDuplicate("Нельзя удалить самого себя из друзей");
        }
        User user = getUser(userId);
        User friend = getUser(friendId);

        if (!user.getFriends().remove(friendId)) {
            log.debug("Дружба не найдена");
            return;
        }

        if (!friend.getFriends().remove(userId)) {
            log.debug("Дружба не найдена");
            return;
        }

        userStorage.updateUser(user);
        userStorage.updateUser(friend);
        log.debug("Пользователи {} и  {} удалены из друзей друг у друга", user, friend);
    }

    public List<User> getFriends(int userId) {
        User user = getUser(userId);
        //Преобразуем Set<Integer> друзей в List<User>
        return user.getFriends().stream()
                   .map(id -> this.getUser(id))
                   .toList();
    }

    public List<User> getCommonFriends(int userId, int otherId) {
        User user = getUser(userId);
        User otherUser = getUser(otherId);
        // копия множества друзей user, чтобы не менять исходные данные.
        Set<Integer> commonFriends = new HashSet<>(user.getFriends());
        // пересечение с множеством друзей otherUser
        commonFriends.retainAll(otherUser.getFriends());
        //Преобразуем Set<Integer> друзей в List<User>
        return commonFriends.stream()
                            .map(id -> this.getUser(id))
                            .toList();
    }

    private void checkEmailUniqueness(String email, Integer currentUserId) {
        boolean emailExists = userStorage.getAllUsers().stream()
                                         .anyMatch(u -> u.getEmail().equals(email)
                                                 && u.getId() != currentUserId);

        if (emailExists) {
            log.error("Email {} уже используется другим пользователем", email);
            throw new ValidationExceptionDuplicate("Email уже используется другим пользователем");
        }
    }

    private void checkLoginUniqueness(String login, Integer currentUserId) {
        boolean loginExists = userStorage.getAllUsers().stream()
                                         .anyMatch(u -> u.getLogin().equals(login)
                                                 && u.getId() != currentUserId);

        if (loginExists) {
            log.error("Логин {} уже используется другим пользователем", login);
            throw new ValidationExceptionDuplicate("Логин уже используется другим пользователем");
        }
    }
}

package ru.yandex.practicum.filmorate.storage.film;

import ru.yandex.practicum.filmorate.model.Film;

import java.util.Collection;

public interface FilmStorage {
    Film addFilm(Film film);

    Film updateFilm(Film film);

    Film getFilm(int id);

    Collection<Film> getAllFilms();
}

package ru.yandex.practicum.filmorate.storage.film;

import org.springframework.stereotype.Component;
import ru.yandex.practicum.filmorate.model.Film;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

@Component
public class InMemoryFilmStorage implements FilmStorage {
    private final Map<Integer, Film> films = new HashMap<>();

    @Override
    public Film addFilm(Film film) {
        film.setId(getNextId());
        films.put(film.getId(), film);
        return film;
    }

    @Override
    public Film updateFilm(Film film) {
        films.put(film.getId(), film);
        return film;
    }

    @Override
    public Film getFilm(int id) {
        return films.get(id);
    }

    @Override
    public Collection<Film> getAllFilms() {
        return films.values();
    }

    private int getNextId() {
        int currentMaxId = films.keySet()
                                .stream()
                                .mapToInt(id -> id)
                                .max()
                                .orElse(0);
        return ++currentMaxId;
    }
}

package ru.yandex.practicum.filmorate.storage.user;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import ru.yandex.practicum.filmorate.model.User;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@Component
public class InMemoryUserStorage implements UserStorage {
    private final Map<Integer, User> users = new HashMap<>();

    @Override
    public User addUser(User user) {
        user.setId(getNextId());
        users.put(user.getId(), user);
        return user;
    }

    @Override
    public User updateUser(User user) {
        users.put(user.getId(), user);
        return user;
    }

    @Override
    public User getUser(int id) {
        return users.get(id);
    }

    @Override
    public Collection<User> getAllUsers() {
        return users.values();
    }

    private int getNextId() {
        int currentMaxId = users.keySet()
                                .stream()
                                .mapToInt(id -> id)
                                .max()
                                .orElse(0);
        return ++currentMaxId;
    }
}

package ru.yandex.practicum.filmorate.storage.user;

import ru.yandex.practicum.filmorate.model.User;

import java.util.Collection;

public interface UserStorage {
    User addUser(User user);

    User updateUser(User user);

    User getUser(int id);

    Collection<User> getAllUsers();
}

package ru.yandex.practicum.filmorate.validator;

import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;
import ru.yandex.practicum.filmorate.annotation.MinReleaseDate;

import java.time.LocalDate;

public class MinReleaseDateValidator implements ConstraintValidator<MinReleaseDate, LocalDate> {
    private static final LocalDate MIN_RELEASE_DATE = LocalDate.of(1895, 12, 28);

    @Override
    public boolean isValid(LocalDate value, ConstraintValidatorContext context) {
        if (value == null) {
            return true;
        }
        return !value.isBefore(MIN_RELEASE_DATE);
    }
}
# ??????? ??????????? ???  ???????
logging.level.controller=INFO
logging.level.exception=WARN
#??? ????????????
logging.level.ru.yandex.practicum.filmorate.service=TRACE

logging.level.org.zalando.logbook:TRACE
# ?????? ?????
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n

<!--
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
        <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
            <encoder>
                <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level - %msg%n</pattern>
            </encoder>
        </appender>

        <root level="INFO">
            <appender-ref ref="CONSOLE"/>
        </root>
</configuration>-->
